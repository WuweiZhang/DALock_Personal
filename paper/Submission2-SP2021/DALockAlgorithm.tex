
% !TEX root = main.tex

\section{The $\DALock$ Mechanism}\label{sec:DALockAlgorithm} %Done
In this section, we present the $\DALock$ mechanism, discuss how $\DALock$ might be implemented, and the strategies an attacker might use when $\DALock$ is deployed. Intuitively, $\DALock$ punishes incorrect password guesses more harshly since an attacker will want to submit popular password guesses to maximize their chances of cracking the users' passwords.

\subsection{$\DALock$} %Done
The $K$-strikes mechanism keeps track of a single parameter $\KOfU$ for each user $u$, which represents the number of consecutive incorrect login attempts on $u$’s account. Each failed login attempt makes $\KOfU$ increment by 1. In contrast, successful authentication resets $\KOfU$ to 0. If we ever have $\KOfU \geq \strikeThreshold$, then the throttling mechanism kicks in, and the authentication server will lock down the account until the user takes corrective action\footnote{For example, the user might be asked to resetting their password via e-mail or wait for some fixed amount of time. In some settings, the user might simply be asked to solve a CAPTCHA challenge. The latter approach has some usability advantages and security drawbacks, e.g., a malicious attacker might pay human to solve the CAPTCHA challenges so that they can continue attempting to guess the user's password.}.

The key-idea behind $\DALock$ is to additionally maintain an extra ``hit count'' variable $\hitCountThresholdOfU{u}$ for each user $u$. Intuitively, $\hitCountThresholdOfU{u}$ measures the total probability mass of all incorrect guesses submitted on $u$’s account. Initially, when a new user $u$ registers, we will have $\hitCountThresholdOfU{u}$= 0 (and $\KOfU$= 0). After each failed attempt with an incorrect password $pw \neq pw_u$, the hit count variable $\hitCountThresholdOfU{u}$ and strike count variable $\KOfU$ will be increased by $\EstP{pw}$ and 1, respectively. i.e.,  $\hitCountThresholdOfU{u}$ += $\EstP{pw}$, and $\KOfU$ += 1. Here, $\EstP{pw}$ denotes an estimate of the probability of the password $pw$. Incorrect passwords are punished more severely when $pw$ is an overly popular password. Upon successful authentications, $\hitCountThresholdOfU{u}$ never resets, unlike the consecutive strike parameter $\KOfU$. $\DALock$ throttles $u$'s account if the ``hit count'' exceeds $\hitCountThreshold$ (i.e., $\hitCountThresholdOfU{u} \geq \hitCountThreshold$) or if there are too many consecutive mistakes (i.e., $\strikeThresholdOfU{u} \geq \strikeThreshold$). For example, suppose that the (estimated) probability of the passwords ``aaa," ``bbb," and ``ccc'' were 3\%, 1.7\% and 0.8\%, respectively. If a user registers with password ``ddd'' and then attempts to login with the previous three passwords, $\hitCountThresholdOfU{u}$ will be set to $0.055=0.03+0.017+0.008$. 

Each time the user (or attacker) attempts to login with a password $pw$ the response from the authentication server will either be (1) ``locked'' if $\hitCountThresholdOfU{u} \geq \hitCountThreshold$ or if $\strikeThresholdOfU{u} \geq \strikeThreshold$, (2) ``correct'' if the guessed password matches the user password i.e., $pw = pw_u$\footnote{To ease presentation, we omit the description of the password hashing algorithm when we describe the authentication server. In practice, we recommend that the authentication server only stores salted password hashes using a moderately expensive key derivation function to increase guessing costs for an offline attacker.}, or (3) ``incorrect password'' otherwise. We formally describe the login flow in \textbf{Algorithm}~\ref{algorithm:DALock} in the Appendix. We remark that the authentication server could intentionally blur this distinction between cases (1) and (3), but this comes at a usability cost, e.g., an honest user would be annoyed if they were repeatedly informed that their password is incorrect when the account is actually locked.

{\noindent \bf Remark:} One could optionally consider initializing the hit count parameter $\hitCountThresholdOfU{u}$ based on the strength of the user's password. For example, if $u$ registers with a weak password, then we might initialize $\hitCountThresholdOfU{u} = \hitCountThreshold/2$ for stronger protection, i.e., so that the account is locked down faster. Similarly, a user with a strong password might be awarded by setting $\hitCountThresholdOfU{u} = \hitCountThreshold$. However, because $\hitCountThresholdOfU{u}$ and $\strikeThresholdOfU{u}$ are stored on the authentication server, this would leak information about the strength of $pw_u$ to an offline attacker, e.g., if an offline attacker sees that $\hitCountThresholdOfU{u} = \hitCountThreshold/2$, they might reasonably infer that the user picked a weak password. \footnote{One could potentially avoid storing $\hitCountThresholdOfU{u}$ unencrypted if one is willing to implement a silent lockout policy where the user cannot distinguish between an incorrect guess and a locked account, but we wish to avoid solutions that blur this distinction.}  



\subsection{$\DALock$ Authentication Server} %Done
To implement $\DALock$, we need an efficient way to estimate the probability $\EstP{pw}$ of each incorrect password $pw$. We consider several instantiations of this frequency oracle. One option is to use password strength meters such as $\ZXCVBN$ ~\cite{USENIX:Wheeler16} or more sophisticated password cracking models~\cite{ USENIX:USBCCKKMMS15,USENIX:MUSKBCC16}. e.g., Markov Models, Probabilistic Context-Free Grammars, or Neural Network. Another naive approach would be to maintain a plaintext list of all user passwords along with their frequencies. However, this approach is inadvisable due to the risk of leaking this plaintext list. Herley and Schechter~\cite{HTS:SchHerMit10} proposed using the count sketch data-structure, which would allow us to estimate the frequency of each password without explicitly storing a plaintext list. However, there are no formal privacy guarantees for this approach. We chose to adopt a differentially private count sketch to address privacy concerns. The authentication server initializes the count sketch $\sigma_{dp}$ $\leftarrow$  DP($\epsilon, \sigma$) by adding Laplace Noise to preserve $\epsilon$-differential privacy. Each time a new user $u$ registers with a new password $pw_u$, it would be added to the count sketch.

We remark that maintaining a differentially private count sketch has many other potentially beneficial applications, e.g., one could use the count sketch to ban weak passwords~\cite{HTS:SchHerMit10} and/or to help identify IP addresses associated with malicious online attacks~\cite{EuroSP:THS19}. One disadvantage is that the attacker will also be able to view the count sketch if the data structure is leaked. The usage of differential privacy helps to minimize these risks. Intuitively, differential privacy hides the influence of any individual password, ensuring that an attacker will not be able to use the count sketch data-structure to help identify any unique password. However, an attacker may still be able to use the data-structure to learn that a particular password is globally popular (without linking that password to a particular user). We argue that this is not a significant risk as most attackers will already know about globally popular passwords, e.g., from prior breaches. 















