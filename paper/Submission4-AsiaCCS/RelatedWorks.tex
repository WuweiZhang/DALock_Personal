% !TEX root = main.tex

% Differential Private Releasing

\section{Related Work and Background}\label{sec: relatedwork}


\subsection{Authentication Throttling} \label{related: Throttling}


\mypara{K-strikes Mechanism} K-strikes mechanism is a straight-forward implementation for authentication throttling. As its name suggests, throttling occurs when $\strikeThreshold$ consecutive incorrect login attempts are detected.  To reduce the cost of expensive overhead caused by unwanted throttling, Brostoff~\cite{brostoff2003ten} et al. suggest setting threshold $\strikeThreshold$ to be 10 instead of 3. They argue the increment risk is limited when a strong password policy is enforced. However, this argument is challenged by empirical analyses of password composition policies~\cite{KSKMBCCE:SIGCHI11, BKPS:ACMEC13}. Many password composition policies do not rule out all low entropy password choices. For instance, it turns out that banning dictionary words does not increase entropy as expected~\cite{KSKMBCCE:SIGCHI11}.

\mypara{Feature-Based Mechanism} Modern throttling mechanisms~\cite{sandhu2005system, gordon2014efficiently} often use features such as geographical location, IP-address, device information, etc., to detect unusual activities. These features can be used to train sophisticated machine learning models to help distinguish between malicious and benign login attempts~\cite{NDSS:FJDBG16}. $\DALock$ takes an orthogonal approach and relies instead on the popularity of the password guesses. One can combine those models with a rigorous throttling system for better performance.

\mypara{Password Distribution-Aware Throttling} In an independent line of work, Tian et al.~\cite{EuroSP:THS19} developed an IP-based throttling mechanism that exploits differences between the distribution of honest login attempts and malicious guesses. In particular, they propose to ``silently block'' login attempts from a particular IP address $ip$ if the system detects too many popular passwords being submitted from $ip$. In more detail, StopGuessing uses a data structure called the binomial ladder filter~\cite{SchHer:MSR18} to (approximately) track the frequency $F(pw)$ of each incorrect password guess $pw$. For each IP address $ip$, the StopGuessing protocol maintains an associated counter $I_{ip} = \displaystyle{\sum_{pw \in \mathcal{P}} F(pw)}$ where $\mathcal{P}$ is a list of incorrect password guesses that have been (recently) submitted from $ip$ --- $I_{ip} $ can be updated without storing $\mathcal{P}$ explicitly. Intuitively (and oversimplifying a bit) if $I_{ip}$ exceeds a predefined threshold $T$, then login attempts from address $ip$ are silently blocked, i.e., even if the attacker (or honest user) submits a correct password, the system will respond that authentication fails. The authors also suggest protecting accounts with weak passwords by setting a user-specific threshold $T(F(pw_{u}))$ based on the strength $F(pw_{u})$ of the password $\PasswordOfU{u}$ of user $u$. Now, if $I_{ip} > T(F(pw_{u}))$, the system will silently reject any password from address $ip$. Both StopGuessing and $\DALock$ exploit differences between the distribution of user passwords and attacker guesses. One of the key differences is that StopGuessing focuses on identifying malicious IP addresses (by maintaining a score $I_{ip}$ for each IP address $ip$) while $\DALock$ focuses on protecting individual accounts by maintaining a ``hit-count'' parameter $\hitCountThreshold{u}$ for each user u. There are several other key differences between the two approaches as well. First, in $\DALock$, the goal of our frequency oracle (e.g., count sketch, password strength meter) is to estimate the \textit{total fraction} of users who have actually selected that particular password --- as opposed to estimating the frequency with which that password has been {\em recently} submitted as an incorrect guess. Second, $\DALock$ does not require silent blocking of login attempts, which could create usability concerns if an honest user is silently blocked when they enter the correct password.  

\vspace{-0.2in}
\subsection{Passwords} \label{related: Passwords}  

\mypara{Password Distribution} To analyze online statistical guessing attacks it is important understanding the distribution of user passwords. Password distributions have been extensively studied since the last decades~\cite{FloHer:WWW07,DavKev:WWW12}. Using leaked password corpora~\cite{SP:Bonneau12,Dataset:RockYou} is a straightforward way to describe the distribution of passwords. Recent works of Wang et al.~\cite{EPRINT:WJHW14,TIFS17:WCWPXG,ESORICS:WanWan16} show that password distributions follow Zipf's law, i.e., leaked password corpora nicely fit Zipf's law distributions. Blocki et al.~\cite{SP:BloHarZho18} later found that Zipf's law nicely fits the Yahoo! password frequency corpus~\cite{SP:Bonneau12,NDSS:BloDatBon16}. 

\mypara{Password Typos}  To test the usability of $\DALock$, it is crucial to reasonably simulate users' mistakes. Recent studies~\cite{CCS:CWPCR17,SP:CAAJR16} from Chatterjee et al. have summarized probabilities of making (various types of) typos when one enters his or her password based on users' studies. Based on the empirically measured data, they proposed two typo-tolerant authentications without sacrificing security. In fact, similar mechanisms have already been deployed in the industry~\cite{News:AmazonTypo}. 

\vspace{-0.2in}
\subsection{Eliminating Dictionary Attacks} 


\mypara{Increasing Cost of Authentication} Pinkas and Sanders~\cite{CCS:PinSan02} proposed using puzzles (e.g., CAPTCHAs) as a way to stop online password crackers. CAPTCHAs are hard AI challenges meant to distinguish people from bots~\cite{EC:vBHL03}. For example, reCAPTCHA~\cite{von2008recaptcha} has been widely deployed, e.g., Google, Facebook, Twitter, CNN, etc. If we assume that CAPTCHAs are only solvable by people, it is possible to mitigate automated online attacks without freezing users' accounts~\cite{SP:BBFNJ10,CCS:BurMarMit11}. Nevertheless, an attacker can always pay humans to solve CAPTCHA challenges~\cite{captchaSolver}. Besides, sophisticated CAPTCHA solvers~\cite{CCS:YTFZFX18} powered by neural networks make it increasingly challenging to design CAPTCHA puzzles that are also easy for a human to solve.  Golla et al.~\cite{SOUPS:GBD17} proposed a fee-based password verification system where a small deposit is necessary to authenticate, which is refunded after successful authentication. A password cracker risks losing its deposit if it is not able to guess the real password.  

\mypara{Eliminating Popular Passwords} One mediation for dictionary attacks is eliminating the existence of weak or popular passwords. Password composition policy is a common approach, but efforts to force users to pick strong passwords by requiring users to include numbers, capital letters, and/or special symbols have shown limited success ~\cite{KSKMBCCE:SIGCHI11, BKPS:ACMEC13}. An alternate approach of Schechter et al.~\cite{HTS:SchHerMit10} is to ban passwords if and only if too many users have picked them using a count-sketch data structure for frequency estimation. A theoretical model by Blocki et al. \cite{BKPS:ACMEC13} shows that this is the optimal approach to boost the minimum entropy of the password distribution.  




