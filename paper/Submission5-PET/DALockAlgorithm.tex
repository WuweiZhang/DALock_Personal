
% !TEX root = main.tex
\vspace*{-\baselineskip}
\section{The $\DALock$ Mechanism}\label{sec:DALockAlgorithm} %Done

In this section, we present the $\DALock$ mechanism, discuss how $\DALock$ might be implemented, and the strategies an attacker might use when $\DALock$ is deployed. Intuitively, $\DALock$ bases lockout decisions on the popularity of incorrect password guesses so that an online attacker attempting to use popular passwords will be locked out more quickly while honest typos are punished less severely. 
\vspace*{-\baselineskip}
\subsection{$\DALock$} %Done
\vspace*{-\baselineskip}
{\bf \noindent Recap: $\strikeThreshold$-strikes mechanism} As briefly discussed in the introduction the $\strikeThreshold$-strikes mechanism keeps track of a single parameter $\KOfU$ for each user $u$, which represents the number of consecutive incorrect login attempts on $u$’s account. $\KOfU$ is incremented by 1 upon each failed login attempt and reset to $\KOfU=0$ upon a successful long. Whenever we exceed the threshold  $\KOfU \geq \strikeThreshold$  the throttling mechanism kicks in and the authentication server locks the account until the user $u$ takes corrective action\footnote{For example, the user might be asked to resetting their password via e-mail or wait for some fixed amount of time. In some settings, the user might simply be asked to solve a CAPTCHA challenge. The latter approach has some usability advantages and security drawbacks, e.g., a malicious attacker might pay human to solve the CAPTCHA challenges so that they can continue attempting to guess the user's password.}.

%Each failed login attempt makes $\KOfU$ increment by 1. In contrast, successful authentication resets $\KOfU$ to 0. If we ever have 

{\bf \noindent Extending the $\strikeThreshold$-strikes mechanism} The key-idea behind $\DALock$ is to additionally maintain an extra ``hit count'' variable $\hitCountThresholdOfU{u}$ for each user $u$. Intuitively, $\hitCountThresholdOfU{u}$ measures the total probability mass of all incorrect guesses submitted on $u$’s account. Initially, when a new user $u$ registers, we will have $\hitCountThresholdOfU{u}$= 0 (and $\KOfU$= 0). After each failed attempt with an incorrect password $pw \neq pw_u$, the hit count variable $\hitCountThresholdOfU{u}$ and strike count variable $\KOfU$ will be increased by $\EstP{pw}$ and 1, respectively. i.e.,  $\hitCountThresholdOfU{u}$ += $\EstP{pw}$, and $\KOfU$ += 1. Here, $\EstP{pw}$ denotes (an estimate of) the probability of the password $pw$. For example, suppose that the (estimated) probability of the passwords ``aaa," ``bbb," and ``ccc'' were 3\%, 1.7\% and 0.8\%, respectively. If a user registers with password ``ddd'' and then attempts to login with the previous three passwords, $\hitCountThresholdOfU{u}$ will be set to $0.055=0.03+0.017+0.008$. Unlike the consecutive strikes parameter $\KOfU$ the hit count  $\hitCountThresholdOfU{u}$  is not reset upon each successful authentication. $\DALock$ throttles $u$'s account if the ``hit count'' exceeds $\hitCountThreshold$ (i.e., $\hitCountThresholdOfU{u} \geq \hitCountThreshold$) or if there are too many consecutive mistakes (i.e., $\strikeThresholdOfU{u} \geq \strikeThreshold$). If an incorrect password guess $pw$ is overly popular this will cause $\hitCountThresholdOfU{u}$ to rapidly reach the threshold so that the account can by locked. 

Now the throttling mechanism will kick if either the hit count or the consecutie strike count reaches our thresholds i.e.,  $\hitCountThresholdOfU{u} \geq \hitCountThreshold$ or if $\strikeThresholdOfU{u} \geq \strikeThreshold$ and the user will be required to take corrective action(s) to \replaced{unlock}{unluck} the account. $\DALock$ is fully compatible with a wide variety of policies. For example, we could require the user to resend their password, authenticate a request to unlock the account via e-mail/phone and/or solve CAPTCHA challenges. We stress that when a user attempts to login with a password $pw$ the authentication server is able to distinguish between the following cases (1) Account locked/throttled: if $\hitCountThresholdOfU{u} \geq \hitCountThreshold$ or if $\strikeThresholdOfU{u} \geq \strikeThreshold$, (2) Correct Login: if the guessed password matches the user password  i.e., $pw = pw_u$ and the account is not locked\footnote{To ease presentation, we omit the description of the password hashing algorithm when we describe the authentication server. In practice, we recommend that the authentication server only stores salted password hashes using a moderately expensive key derivation function to increase guessing costs for an offline attacker.}, or (3) Incorrect Password: the account is not locked but the password is incorrect. We remark that StopGuessing \cite{EuroSP:THS19} necessarily blurs the distinction between cases (1) and (3), but this can induce a usability cost, e.g., an honest user might be annoyed if they were repeatedly informed that their password is incorrect when, in reality, the account is actually locked. 

We use the notation $\KPsiDALock{\strikeThreshold}{\hitCountThreshold}$ to denote $\DALock$ \replaced{instantiated}{instanted} with hit-count threshold $\hitCountThreshold$ and consecutive strike threshold $\strikeThreshold$. Observe that when $ \hitCountThreshold = \infty$, the authentication server is actually running the classical $\strikeThreshold$-strikes lockout policy. In most of our experiments we will set $\strikeThreshold=10$ when instantiating $\DALock$ and tune $\hitCountThreshold$ to balance security and usability. The hope is that by tuning  $\hitCountThreshold$  we can achieve (1) stronger security than {\em both} the classical $\strikeThreshold=3$-strikes mechanism and $\strikeThreshold=10$-strikes mechansim, and (2) usability superior to the $\strikeThreshold=3$ mechanism and comparable to the $\strikeThreshold=10$ mechanism. 

 To deploy $\DALock$ with a finite hit-count parameter $ \hitCountThreshold$, an authentication server needs to use a frequency oracle to update the hit count after each failed login attempt.  In this work, we consider two concrete approaches the authentication server might adopt: (differentially private) count sketch estimator and password strength models. We use $\EstimateP{pw}{\Estimator}$ to denote the estimated popularity (probability) of a password $pw$ estimated by the estimator $\Estimator$, e.g., given a count sketch $\sigma$ we would use  $\EstimateP{pw}{\sigma} = \frac{\mathbf{Estimate}(pw,\sigma)}{\mathbf{TotalFreq(\sigma)}}$. 


{\noindent \bf Remark:} One could optionally consider initializing the hit count parameter $\hitCountThresholdOfU{u}$ based on the strength of the user's password. For example, if $u$ registers with a weak password, then we might initialize $\hitCountThresholdOfU{u} = \hitCountThreshold/2$ for stronger protection, i.e., so that the account is locked down faster when $\hitCountThresholdOfU{u}$ reached $\hitCountThreshold$. Similarly, a user with a strong password might be awarded by setting $\hitCountThresholdOfU{u} = 0$ so that the throttling mechanism will not be activated as quickly. However, because $\hitCountThresholdOfU{u}$ and $\strikeThresholdOfU{u}$ are stored on the authentication server, this would signal information about the strength of $pw_u$ to an offline attacker. While this seems undesirable, a recent counter-intuitive result showed that {\em noisy} strength signals can actually help deter a rational utility maximizing password cracker~\cite{GameSec:BaiBloHar21} if the signaling scheme is tune\added{d} appropriately. Thus, it is possible that a noisy (randomized) mechanism to tune $\hitCountThresholdOfU{u}$ based on the strength of the user's password could help deter offline attackers. Alternatively, if one is willing to implement a silent lockout policy where the user cannot distinguish between an incorrect guess and  a locked account, it would be possible to encrypt the hit-count $\hitCountThresholdOfU{u}$ using a key derived from the user's password~\cite{EuroSP:THS19,CCS:CWPCR17}.

\vspace*{-\baselineskip}
\subsection{$\DALock$ Authentication Server} %Done

To implement $\DALock$, we need an efficient way to estimate the probability $\EstP{pw}$ of each incorrect password $pw$. We consider several instantiations of this frequency oracle. One option is to use password strength meters such as $\ZXCVBN$ ~\cite{USENIX:Wheeler16} or more sophisticated password cracking models~\cite{ USENIX:USBCCKKMMS15,USENIX:MUSKBCC16}. e.g., Markov Models, Probabilistic Context-Free Grammars, or Neural Network. Another naive approach would be to maintain a plaintext list of all user passwords along with their frequencies. However, this approach is inadvisable due to the risk of leaking this plaintext list. Herley and Schechter~\cite{HTS:SchHerMit10} proposed using the count sketch data-structure, which would allow us to estimate the frequency of each password without explicitly storing a plaintext list. However, there are no formal privacy guarantees for this approach. We chose to adopt a differentially private count sketch to address privacy concerns. The authentication server initializes the count sketch $\sigma_{dp}$ $\leftarrow$  DP($\epsilon, \sigma$) by adding Laplace Noise to preserve $\epsilon$-differential privacy. Each time a new user $u$ registers with a new password $pw_u$, it would be added to the count sketch.

We remark that maintaining a differentially private count sketch has many other potentially beneficial applications, e.g., one could use the count sketch to ban weak passwords~\cite{HTS:SchHerMit10} and/or to help identify IP addresses associated with malicious online attacks~\cite{EuroSP:THS19}. One disadvantage is that the attacker will also be able to view the count sketch if the data structure is leaked. The usage of differential privacy helps to minimize these risks. Intuitively, differential privacy hides the influence of any individual password, ensuring that an attacker will not be able to use the count sketch data-structure to help identify any unique password. However, an attacker may still be able to use the data-structure to learn that a particular password is globally popular (without linking that password to a particular user). We argue that this is not a significant risk as most attackers will already know about globally popular passwords, e.g., from prior breaches. 
