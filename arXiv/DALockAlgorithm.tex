
% !TEX root = main.tex

\section{The $\DALock$ Mechanism}\label{sec:DALockAlgorithm} %Done
In this section, we present the $\DALock$ mechanism, discuss how $\DALock$ might be implemented and the strategies that an attacker might use when $\DALock$ is deployed. Intuitively, $\DALock$ punishes incorrect password guesses more harshly if the guessed password $pw$ is overly popular since an attacker will want to submit popular password guesses to maximize their chances of cracking the users' passwords.

\subsection{$\DALock$} %Done
In the classic $K$-strike throttling mechanism we keep track of a parameter $\KOfU$ which tracks the number of consecutive incorrect login attempts for each user $u$. After each consecutive login attempt the parameter is $\KOfU$ and the parameter $\KOfU$ is reset to $0$ whenever $u$ authenticates successfully. If we ever have $\KOfU \geq \strikeThreshold$ then throttling mechanism kicks in and the authentication server will lock down the account until the user takes some action\footnote{For example, the user might be asked to  resetting his password via e-mail or wait for some fixed amount of time. In some settings the user might simply be asked to solve a CAPTCHA challenge. The latter approach has some usability advantages and security drawbacks e.g., a malicious password might pay to solve the CAPTCHA challenges so that he can continue attempting to guess the user's password}.

The key-idea behind $\DALock$ is to additionally maintain an extra ``hit count'' variable $\hitCountThresholdOfU{u}$ for each user $u$. Intuitively, $\hitCountThresholdOfU{u}$ measures the total probability mass of all incorrect password guesses submitted for user $u$. Initially, when a new user registers we will have $\hitCountThresholdOfU{u}=0$ (and $\KOfU =0$). After each attempted login with an incorrect password $pw \neq pw_u$ the hit count is incremented so that $\hitCountThresholdOfU{u}+= \EstP(pw)$. Here, $\EstP(pw)$ denotes an estimate for the probability of the password $pw$ so that incorrect passwords are punished more severely when $pw$ is an overly popular password. Unlike the consecutive strike parameter $\KOfU$ which is reset to $0$ after each successful login, the hit count parameter can only be incremented. $\DALock$ throttles $u$'s account if the ``hit count'' exceeds $\hitCountThreshold$ (i.e., $\hitCountThresholdOfU{u} \geq \hitCountThreshold$) or if there are too many consecutive mistakes (i.e., $\strikeThresholdOfU{u} \geq \strikeThreshold$)  For example, suppose that the (estimated) probability of the passwords ``aaa," ``bbb" and ``ccc'' were 3\%, 1.7\% and 0.8\%. If a user registers with a password ``ddd'' and then attempts to login with the previous three passwords, then $\hitCountThresholdOfU{u}$ will be set to $0.055=0.03+0.017+0.008$. 

Each time the user (or attacker) attempts to login with a password $pw$ the response will either be (1) ``locked'' if $\hitCountThresholdOfU{u} \geq \hitCountThreshold$ or if $\strikeThresholdOfU{u} \geq \strikeThreshold$, (2) ``correct'' if the guessed password matches the user password i.e., $pw = pw_u$\footnote{To ease presentation we omit the description of the password hashing algorithm when we describe the authentication server. In practice, we recommend that the authentication server only stores salted password hashes using a moderately expensive key derivation function to increase guessing costs for an offline attacker.} or (3) ``incorrect password'' otherwise. We demonstrate the login flow in \textbf{Algorithm}~\ref{algorithm:DALock}, Appendix. We remark that the authentication server could intentionally blur this distinction between cases (1) and (3), but that this comes at a usability cost e.g., an honest user would be annoyed if they were repeatedly informed that their password is incorrect whenever the account is actually locked.



%We start the discussion by first introducing the classic $K$-strike throttling mechanism. As its name suggests, throttling happens when one makes $K$ consecutive mistakes. To achieve this goal, $K$-strike mechanism maintains a counter $\KOfU$ for each user u to record how many incorrect attempts were made. Typically, $\KOfU$ is reset to 0 whenever u logins successfully. Some systems also reset $\KOfU$ to 0 after a certain amount of time and/or maintain separate counters for different IP addresses. In our experiments we consider the $K$-strike mechanism where $\KOfU$ is reset to 0 only after successful login attempts. 

%The $\DALock$ mechanism maintains an extra ``hit count" variable $\hitCountThresholdOfU{u}$ for each user. Intuitively, $\hitCountThresholdOfU{u}$ measures the total probability mass of all incorrect password guesses submitted for user $u$. For example, suppose that the (estimated) probability of the passwords ``aaa," ``bbb" and ``ccc'' were 3\%, 1.7\% and 0.8\%. $\hitCountThresholdOfU{u}$ is set to $0.055=0.03+0.017+0.008$ if one fails to login into the account with those passwords. We demonstrate the login flow in \textbf{Algorithm}~\ref{algorithm:DALock}, Appendix. Here, $\PasswordOfU{u}$ denotes the actual password of user $u$ and $\hitCountThreshold$ (resp. $\strikeThreshold$) are global threshold parameters. $\DALock$ locks $u$'s account if the ``hit count'' exceeds $\hitCountThreshold$ (i.e., $\hitCountThresholdOfU{u} \geq \hitCountThreshold$) or if there are too many consecutive mistakes (i.e., $\strikeThresholdOfU{u} \geq \strikeThreshold$). \footnote{We omit the description of the password hashing algorithm to ease presentation. Any secure implementation would need to use a salted password hash algorithm with plenty of key-stretching to increase guessing costs for an offline attacker.}


{\noindent \bf Remark:} One could optionally consider initializing the hit count parameter $\hitCountThresholdOfU{u}$ based on the strength of the user's password. For example, if $u$ registers with a weak password then we might initialize $\hitCountThresholdOfU{u} = \hitCountThreshold/2$ for stronger protection i.e., so that the account is locked down faster. Similarly, a user with a strong password might be awarded by setting $\hitCountThresholdOfU{u} = \hitCountThreshold$. However, because $\hitCountThresholdOfU{u}$ and $\strikeThresholdOfU{u}$ are stored on the authentication server this would leak information about the strength of $pw_u$ to an offline attacker e.g., if an offline attacker sees that $\hitCountThresholdOfU{u} = \hitCountThreshold/2$ he might reasonably infer that the user picked a weak password. \footnote{One could potentially avoid storing $\hitCountThresholdOfU{u}$ unencrypted if one is willing to implement a silent lockout policy where the user cannot distinguish between an incorrect guess and a locked account, but we wish to avoid solutions that blur this distinction.}  



\subsection{$\DALock$ Authentication Server} %Done
To implement $\DALock$ we need an efficient way to estimate the probability $\EstP(pw)$ of each incorrect password $pw$. We consider several instantiations of this frequency oracle. One option is to use password strength meters such as $\ZXCVBN$ or more sophisticated password cracking models e.g., Markov Models, Probabilistic Context Free Grammars, or Neural Networks. Another naive approach would be to simply maintain a plaintext list of all user passwords along with their frequencies. However, this approach is inadvisable due to the risk of leaking this plaintext list. Herley and Schechter~\cite{HTS:SchHerMit10} proposed the use of the Count-Sketch data-structure which would allow us to estimate the frequency of each password without explicitly storing a plaintext list although there are no formal privacy guarantees to this approach. We chose to adopt a Differentially Private Count-Median-Sketch. The authentication server initializes the Count-Sketch $\sigma_{dp}$ $\leftarrow$  DP($\epsilon, \sigma$) by adding Laplace Noise to preserve $\epsilon$-differential privacy and each time a new user $u$ registers a new password  $pw_u$ would be added to the Count Sketch.

%There are several ways to accomplish this task. Password strength meters such as $\ZXCVBN$ can provide reasonably accurate measurement of password strength\cite{CCS:GolDur18}; nevertheless it can be a usability concerns for a user if they accidentally enters a typo result in low entropy. Another naive approach would be to simply maintain a plaintext list of all user passwords along with their frequencies. However, this approach is inadvisable due to the risk of leaking this plaintext list. Herley and Schechter~\cite{HTS:SchHerMit10} proposed the use of the Count-Sketch data-structure which would allow us to estimate the frequency of each password without explicitly storing a plaintext list. However, there are no formal privacy guarantees. We chose to adopt a Differentially Private Count-Median-Sketch. In our experiments we find that the Laplace Noise added to preserve differential privacy does not adversely affect the performance of $\DALock$, and we also found that Differentially Private Count-Median-Sketch outperforms its differentially private counterparts Count-Mean and Count-Min. In the rest of this, we simply refer to Count-Median-Sketch as Count Sketch.

We remark that maintaining a Differentially Private Count-Sketch has many other potentially beneficial applications e.g., one could use the Count-Sketch to ban weak passwords~\cite{HTS:SchHerMit10} and/or to help identify IP addresses associated with malicious online attacks~\cite{EuroSP:THS19}. One disadvantage is that the attacker will also be able to view the Count-Sketch data-structure if the data-structure is leaked. The usage of differential privacy helps to minimize these risks. Intuitively, differential privacy hides the influence of any individual password ensuring that an attacker will not be able to use the Count-Sketch data-structure to help identify any unique passwords. However, an attacker may still be able to use the data-structure to learn that a particular password is globally popular (without linking that password to a particular user). We argue that this is not a major risk as most attackers will already know about globally popular passwords e.g., from prior breaches. 

% an efficient data structure to accurately, privately, and securely estimate the probability of each user password. We adopt Differential Private Count-Median-Sketch to store password distribution as it meets all the expectations. Based on our experiments, Count-Median-Sketch has the lowest $l_1$ error on average compare to Count-Mean-Sketch and Count-Min-Sketch. 

%

%There are multiple ways to estimate password frequencies and popularities besides Count-Sketch. For instance, one can use existing password corpora, and password strength meter to estimate the distribution of the password; however, one advantage of using Count-Sketch is it can be used in other applications,  e.g., to help ban weak passwords or to identify malicious IP addresses\cite{EuroSP:THS19}.  A disadvantage is the potential risks associated with leaking the Count-Sketch data-structure if there is a breach. The usage of DP helps to minimize (but may not completely eliminate) these risks. 

%{\bf Using/Releasing Differentially Private Count Sketch: } 
%In this work, we consider the actual usage of a distribution in $\DALock$ as releasing it. We assume that $\Adversary$ can potentially acquire knowledge based on the feedback of $\DALock$ and therefore it is crucial to ensure privacy protection. In this work we consider the centralized model of differential privacy. i.e. We assume the server periodically updates the a securely stored and release a differentially private version of it by batching. One natural question is whether such approach is sustainable for essential multiple releases in long term. Our results show that one can achieve high accuracy with low privacy budget e.g. $\epsilon = 0.1$ which reduce the cost of cumulative privacy loss.













